/*
 * 예제130-3 32*32도트매트릭스에
 * 32*32 모노비트맵을 sram이 아닌 flash메모리에 저장해라!
 */
/*
 * 스케치는 프로그램 저장 공간 2658 바이트(8%)를 사용. 최대 32256 바이트.
전역 변수는 동적 메모리 747바이트(36%)를 사용, 1301바이트의 지역변수가 남음.
스케치는 프로그램 저장 공간 2662 바이트(8%)를 사용. 최대 32256 바이트.
전역 변수는 동적 메모리 363바이트(17%)를 사용, 1685바이트의 지역변수가 남음.
 */

#include "LedControl.h"
LedControl lc=LedControl(12,11,10,4); // DIN, CLK, CS, DeviceNUM
LedControl lc2=LedControl(12,11,9,4); // DIN, CLK, CS, DeviceNUM
LedControl lc3=LedControl(12,11,8,4); // DIN, CLK, CS, DeviceNUM
LedControl lc4=LedControl(12,11,7,4); // DIN, CLK, CS, DeviceNUM

#define image_count 3

//배열의 총길이가 32*32픽셀
//4*32 bytes = 128bytes
//한모듈당 8줄씩 담당..
//const PROGMEM uint16_t charSet[]
const PROGMEM byte nockanda[image_count][128] = {
  {
    B00000000, B00000000, B00000000, B00000000,
    B00000000, B00000000, B00000000, B00000000,
    B00000000, B00000000, B00000100, B00000000,
    B00000001, B00000000, B00000100, B01000000,
    B00010001, B00001000, B00000110, B01000000,
    B00010000, B10001000, B10111111, B01000000,
    B00011000, B10001000, B10000000, B01011000,
    B00111100, B10011000, B10000000, B01100000,
    B00100100, B10010100, B10011110, B01000000,
    B00100000, B00010110, B10010010, B01000000,
    B00101111, B10000000, B10001100, B00000000,
    B00001000, B10000000, B10000010, B00000000,
    B00001000, B10001111, B11000001, B00000000,
    B00001001, B10001000, B01000001, B11111100,
    B00001111, B00001111, B11000000, B00000000,
    B00000000, B00001100, B00000000, B00000000,
    B00000000, B00000000, B00000000, B00000000,
    B00000000, B00000000, B00000000, B00000000,
    B00100000, B00000001, B00000000, B00000000,
    B00100000, B00000001, B00001111, B10010000,
    B00100000, B01111101, B01001000, B00010000,
    B00011111, B00000111, B11001000, B00010000,
    B00000010, B01111100, B10001000, B00010000,
    B00000010, B00000100, B10001000, B00011100,
    B00011111, B00000100, B00001000, B00010000,
    B00000000, B00001000, B00001111, B10010000,
    B00001111, B00000001, B00000000, B00010000,
    B00000001, B10000001, B10000000, B00010000,
    B00000000, B01000001, B11100000, B00010000,
    B00000000, B01000000, B00000000, B00000000,
    B00000000, B11000000, B00000000, B00000000,
    B00000000, B00000000, B00000000, B00000000
  }, 
  {
    B00000000, B01111111, B11111100, B00000000,
    B00000001, B11111111, B11111111, B00000000,
    B00000011, B11111111, B11111111, B10000000,
    B00000111, B11111111, B11111111, B11100000,
    B00011111, B11111000, B00111111, B11110000,
    B00011111, B11000000, B00000111, B11110000,
B00111111, B10000000, B00000011, B11111000,
B01111110, B00000000, B00000000, B11111100,
B01111110, B00000000, B00000000, B11111100,
B11111100, B01100000, B00110000, B01111110,
B11111000, B11110000, B01111000, B00111110,
B11111000, B11110000, B01111000, B00111110,
B11111000, B01100000, B00110000, B00111111,
B11110000, B00000000, B00000000, B00011111,
B11110000, B00000000, B00000000, B00011111,
B11110000, B00000000, B00000000, B00011111,
B11110000, B00000000, B00001110, B00011111,
B11110000, B00000000, B00001110, B00011111,
B11110000, B01110000, B00011110, B00011111,
B11111000, B01111000, B00011110, B00111111,
B11111000, B01111100, B00111110, B00111110,
B11111000, B01111110, B01111100, B00111110,
B11111100, B00111111, B11111100, B01111110,
B01111110, B00011111, B11111000, B11111100,
B01111110, B00000111, B11110000, B11111100,
B00111111, B10000000, B00000001, B11111000,
B00011111, B11000000, B00000111, B11110000,
B00011111, B11110000, B00011111, B11110000,
B00001111, B11111111, B11111111, B11100000,
B00000111, B11111111, B11111111, B11000000,
B00000001, B11111111, B11111111, B00000000,
B00000000, B01111111, B11111100, B00000000
  },
  {
    B00000000, B00000000, B00000000, B00000000,
B00000000, B00000000, B00000000, B00000000,
B00000000, B00000000, B00000000, B00000000,
B00111111, B00111111, B00000000, B00000000,
B00000001, B00000000, B00001111, B00100000,
B00000001, B00010000, B00000001, B00100000,
B00000001, B00010000, B00000001, B00100000,
B00000000, B00011111, B00000101, B00100000,
B00011111, B11000010, B00000100, B00111100,
B00000001, B00011111, B10000111, B11100000,
B00000001, B00000000, B00000000, B00100000,
B00000001, B00000000, B00000000, B00100000,
B00000001, B00000111, B11100000, B00100000,
B00000000, B00000000, B00100000, B00100000,
B00000000, B00000000, B00100000, B00000000,
B00000000, B00000000, B00000000, B00000000,
B01111100, B00000000, B00000000, B00000000,
B01000100, B00000000, B00000000, B00000000,
B00001110, B00000000, B00000001, B11110000,
B00001011, B00001110, B01000011, B00010000,
B00001101, B00001011, B01100010, B00010000,
B00000100, B00011001, B00100011, B10010000,
B00000100, B00010001, B00101000, B11100000,
B00011111, B11010001, B00110000, B00000000,
B00000000, B00011001, B00100001, B00000000,
B00000100, B00001110, B00100001, B00010000,
B00011111, B00000000, B00100001, B10010000,
B00000000, B00000000, B00000000, B00010000,
B00000000, B00000000, B00000000, B00000000,
B00001111, B00000000, B00001111, B11111111,
B00010001, B00000000, B00000000, B00000000,
B00011111, B00000000, B00000000, B00000000,

  }
};
void setup() {
  //모든 dot를 초기화
  for(int i = 0;i<lc.getDeviceCount();i++){
    lc.shutdown(i,false);
    lc.setIntensity(i,8);
    lc.clearDisplay(i);
  }
  for(int i = 0;i<lc2.getDeviceCount();i++){
    lc2.shutdown(i,false);
    lc2.setIntensity(i,8);
    lc2.clearDisplay(i);
  }
  for(int i = 0;i<lc3.getDeviceCount();i++){
    lc3.shutdown(i,false);
    lc3.setIntensity(i,8);
    lc3.clearDisplay(i);
  }
  for(int i = 0;i<lc4.getDeviceCount();i++){
    lc4.shutdown(i,false);
    lc4.setIntensity(i,8);
    lc4.clearDisplay(i);
  }
  
}

int image_index = 0;
void loop() {
  // put your main code here, to run repeatedly:
  setdotmatrix(image_index);

  if(image_index == image_count-1){
    image_index=0;
  }else{
    image_index++;
  }
  
  delay(1000);
}

void setdotmatrix(byte imagenum){
  //픽셀드로잉
  //0~31 bytes
  for(int i = 0;i<8;i++){
    //i가 라인번호이다.. 그러므로 i가 고정되었을때 device가 회전한다.
    for(int device=0;device<4;device++){
      //0  0,1,2,3    (4*i)+device
      //1  4,5,6,7    (4*i)+device
      //2  8.9,10,11  (4*i)+device
      //....
      //7  ...... 31
      lc.setRow(3-device,i,pgm_read_byte(&nockanda[imagenum][(4*i)+device]));
    }
  }
  //32~63 bytes
  for(int i = 0;i<8;i++){
    for(int device=0;device<4;device++){
      //0  32, 33, 34 ,35
      //.....  63
      lc2.setRow(3-device,i,pgm_read_byte(&nockanda[imagenum][32+(4*i)+device]));
    }
  }
  //64~95 bytes
  for(int i = 0;i<8;i++){
    //i가 라인번호이다.. 그러므로 i가 고정되었을때 device가 회전한다.
    for(int device=0;device<4;device++){
      //0  0,1,2,3    (4*i)+device
      //1  4,5,6,7    (4*i)+device
      //2  8.9,10,11  (4*i)+device
      //....
      //7  ...... 31
      lc3.setRow(3-device,i,pgm_read_byte(&nockanda[imagenum][64+(4*i)+device]));
    }
  }
  //96 ~ 127
  for(int i = 0;i<8;i++){
    for(int device=0;device<4;device++){
      //0  32, 33, 34 ,35
      //.....  63
      lc4.setRow(3-device,i,pgm_read_byte(&nockanda[imagenum][96+(4*i)+device]));
    }
  }
}
